package xxs.common.module.utils.tree.ext1;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.core.JsonProcessingException;import lombok.Builder;import lombok.Data;import org.springframework.util.CollectionUtils;import xxs.common.module.utils.tree.ext1.BaseTreeElement;import java.lang.reflect.InvocationTargetException;import java.util.*;import java.util.function.Predicate;import java.util.stream.Collectors;public class TreeUtils {	/**	 * 后端树过滤接口--先查询出来被构造的树之后，再在内存中过滤他的值	 * @param treeList	 * @param predicate 过滤条件。	 * @return	 */	public static  <T extends BaseTreeElement>  List<T> filterTreeList(List<T> treeList, Predicate<T> predicate ) {		List<T> filterTree = new ArrayList<>();		for (T t : treeList) {			T node = filterTree(t, predicate);			filterTree.add(node);		}		return filterTree.stream().filter(Objects::nonNull).collect(Collectors.toList());	}	/**	 * 过滤树	 * @param tree	 * @param predicate	 * @return	 */	private static  <T extends BaseTreeElement> T filterTree(T tree, Predicate<T> predicate) {		if(isRemoveNode(tree, predicate)){			return null;		}		Iterator<T> iterator = (Iterator<T>)tree.getChildren().iterator();		while (iterator.hasNext()){			T child = iterator.next();			deleteNode(child, iterator, predicate);		}		return tree;	}	/**	 * 删除节点	 * @param child	 * @param iterator	 */	private static  <T extends BaseTreeElement> void deleteNode(T child, Iterator<T> iterator, Predicate<T> predicate) {		if(isRemoveNode(child, predicate)){			iterator.remove();			return;		}		List<T> childrenList = (List<T>)child.getChildren();		if(childrenList==null||childrenList.size()==0){			return;		}		Iterator<T> children = childrenList.iterator();		while (children.hasNext()){			T childChild = children.next();			deleteNode(childChild,children, predicate);		}	}	/**	 * 判断该节点是否该删除	 * @param root	 * @return ture 需要删除  false 不能被删除	 */	private static  <T extends BaseTreeElement> boolean isRemoveNode(T root, Predicate<T> predicate) {		List<T> children = (List<T>) root.getChildren();		// 叶子节点		if(children==null||children.size()==0){			return !predicate.test(root);		}		// 子节点		if(predicate.test(root)){			return false;		}		boolean bool = true;		for (T child : children) {			if(!isRemoveNode(child,predicate)){				bool = false;				break;			}		}		return bool;	}    //获取树结构根据一个list	public static <T extends BaseTreeElement>  List<T> getTreeByList(List<T> data){		return  getTreeByList(data,0L,null,null);	}	public static <T extends BaseTreeElement>  List<T> getTreeByList(List<T> data,Long baseNodeIdValue){		return  getTreeByList(data,baseNodeIdValue,null,null);	}	public static <T  extends BaseTreeElement>  List<T>  getTreeByList(List<T> data,Long baseNodeIdValue, Predicate<T> predicate,Consumer<T,T> consumer){		if(CollectionUtils.isEmpty(data)){			return Collections.EMPTY_LIST;		}		if(predicate!=null){			data=data.stream().filter((item)->{				return predicate.test(item);			}).collect(Collectors.toList());		}		List<T> allData=data;		List<T> allBaseNodes = allData.stream().filter(item -> {			Long fieldValue = item.getParentId();			return fieldValue!=null&& fieldValue.equals(baseNodeIdValue);		}).collect(Collectors.toList());		if(CollectionUtils.isEmpty(allBaseNodes)){			return Collections.EMPTY_LIST;		}		if(consumer!=null){			for (T t : allBaseNodes) {				consumer.accept(null,t);			}		}		recursion(allData,allBaseNodes,consumer);		return allBaseNodes;	}	private static   <T extends BaseTreeElement>  void recursion(List<T> allData,List<T> baseNodes, Consumer<T,T> consumer){		for (T item:baseNodes) {			List<T> children = allData.stream().filter(t -> {				Long parentValue =  t.getParentId();				Long idValue = item.getId();				return  idValue.equals(parentValue);			}).collect(Collectors.toList());			if(consumer!=null){				for (T t : children) {					consumer.accept(item,t);				}			}			if(!CollectionUtils.isEmpty(children)){				item.setChildren(children);				recursion(allData,children,consumer);			}		}	}	/*先构造出tree，再计算出tree中的子树的数量。 这里的作用是去重，比如如果有一个值是多对多的关系，那么需要去掉重复的，不然统计出来的数量会有问题。*//*	public   static  Set<Long> countTree2(List<BusinessCategoryTreeNode> tree) {		Set<Long> countSetIds=new HashSet<>();		Set<Long> voidSetIds=new HashSet<>();		//判断树不为空且size大于0		if (org.apache.commons.collections.CollectionUtils.isNotEmpty(tree)) {			//遍历树			for (BusinessCategoryTreeNode resVO : tree) {				//不确定有多少级，开始递归				voidSetIds = countTree2(resVO.getChildren());				//本身的count值 + 所有子级的count值				Set<Long> businessCategoryTableIds = resVO.getBusinessCategoryTableIds();				if(CollectionUtils.isEmpty(businessCategoryTableIds)){					businessCategoryTableIds=new HashSet<>();				}				businessCategoryTableIds.addAll(voidSetIds);				resVO.setBusinessCategoryTableIds(businessCategoryTableIds);				countSetIds.addAll(resVO.getBusinessCategoryTableIds());			}		}		//返回子级所有count值总数		return countSetIds;	}*/    //先构造出tree，再计算出tree中的子树的数量。	public   static <C extends BaseTreeElement> Long countTree(List<C> tree) {		//子级所有count值总数		Long count = 0L;		//接收返回值		Long voidCount = 0L;		//判断树不为空且size大于0		if (!(tree==null||tree.size()==0)) {			//遍历树			for (C resVO : tree) {				//不确定有多少级，开始递归				voidCount = countTree(resVO.getChildren());				//本身的count值 + 所有子级的count值				resVO.setCount(resVO.getCount()==null?0L:resVO.getCount() + voidCount);				//累计本级别的count值				count += resVO.getCount();			}		}		//返回子级所有count值总数		return count;	}	public  static <T extends BaseTreeElement,U extends Comparable> List<U> getChildrenTreeIds(List<T> allData,U id){		if(CollectionUtils.isEmpty(allData)){			return Collections.EMPTY_LIST;		}		List<U> ids=new ArrayList<>();		ids.add(id);		List<T> baseNodes = allData.stream().filter(item -> {			U parentIdProValue = (U) item.getParentId();			return id.equals(parentIdProValue);		}).collect(Collectors.toList());		if(CollectionUtils.isEmpty(baseNodes)){			return ids;		}		for (T item: baseNodes) {			U idProValue = (U) item.getId();			ids.add(idProValue);		}		recursionGetChildrenTreeIds(allData,baseNodes,ids);		return ids;	}	/*递归获取子节点的Id数据*/	private static <T extends BaseTreeElement,U extends Comparable> void recursionGetChildrenTreeIds(List<T> allData, List<T> baseNodes, List<U> ids) {		if(baseNodes!=null){			for (T item: baseNodes) {				List<T> nodes = allData.stream().filter(i -> {					U parentIdProValue = (U)  i.getParentId();					U idProNameValue = (U) item.getId();					return idProNameValue.equals(parentIdProValue);				}).collect(Collectors.toList());				if(nodes!=null){					List<U> collect = nodes.stream().map(it -> {						U idProNameValue = (U) it.getId();						return idProNameValue;					}).collect(Collectors.toList());					ids.addAll(collect);					recursionGetChildrenTreeIds(allData,nodes,ids);				}			}		}	}	@Data	@Builder	static  class TestNode implements  BaseTreeElement<TestNode>{		private Long id;		private Long parentId;		private String name;		@JsonInclude(value = JsonInclude.Include.NON_EMPTY )		private List<TestNode> children=new ArrayList<>();		private String text;		@Override		public Long getCount() {			return null;		}		@Override		public void setCount(Long count) {		}	}	public static void main(String[] args) throws JsonProcessingException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {	}}